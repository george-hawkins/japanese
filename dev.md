Dev work
========

This page covers software development (and using ChatGPT) for Japanese related tasks.

ChatGPT
-------

I asked ChatGPT:

> Create a sentence or short paragraph in Japanese that contains all the modern kana, either as hiragana
> or in the readings of the kanji. Generate the output as an HTML snippet in the following format:
> 
> ```html
> <p><!-- Japanese text using kanji and kana. --></p>
> <p><!-- Japanese text entirely in kana. --></p>
> <p><!-- English translation. --></p>
> <hr>
> ```
> 
> Do not include any additional text or explanation outside the HTML snippet. Do not use `<ruby>` tags
> or furigana in the part that uses kanji.

It produced output like this:

```
<p>私は日本の文化を学ぶために毎日努力しています。</p>
<p>わたしはにほんのぶんかをまなぶためにまいにちどりょくしています。</p>
<p>I am making an effort every day to learn about Japanese culture.</p>
<hr>
```

### Furigana

ChatGPT is basically terrible at furigana using the HTML `<ruby>` tag (even using 4o).

It misgroups thigs, e.g.:

```
<ruby>私は<rt>わたし</rt></ruby>
```

Above, the わたし should just be over the 私 but its included the は in the same element so the furigana overflows the kanji and appears over the particle too.

It often adds furigana for characters that are already hiragana or katakana.

It often fails to add furigana over some of the kanji even if you specifically tell it to add furigana for all kanji.

If you point out these issues, it does the usual thing of acknowledging the issues, regenerating the result and claiming it's addressed the issues when in fact it just makes them again.

### Quering ChatGPT using Python

I created a script to query ChatGPT using Python, you can find all the details in [`chatgpt/README.md`](chatgpt/README.md).

Copying HTML snippets to the clipboard
--------------------------------------

I tried copying HTML snippets generated by ChatGPT directly to the clipboard so they could e.g. be pasted directly into _Pages_ (which unlike _TextEdit_ can handle furigana).

Aside: if you open the Wikipedia [Furigana page](https://en.wikipedia.org/wiki/Furigana) and copy the <ruby>日<rt>に</rt></ruby><ruby>本<rt>ほん</rt></ruby><ruby>語<rt>ご</rt></ruby> example and paste it into _Pages_, you'll find both Safari and Chrome do an oddly unsatisfactory job - Chrome pastes the furigana as normal text so you get a line with にほんご followed by a line with 日本語. And Chrome tries harder but the result is just as bad, it create a 3x2 table, placing the furigana in the top cells of the table and the kanji in the bottom cells rather than using the proper furigana support (furigana is grouped in with what _Pages_ calls _Phonetic guide text_).

First I didn't have a lot of luck with copying HTML straight to the clipboard using Mac tools like `pbcopy` and `textutil` but both demonstrate rather arbitrary behaviors especially when dealing with Japanese text.

As far as I understand it, the following should work:

```
echo '<p>abc</p>' | pbcopy -Prefer html
```

But this always just resulted in the plain text string `<p>abc</p>` ending up in the clipboard.

I tried working out if I should be using a bit more HTML to wrap the input, beyond just the `<p>...</p>` tag. I hoped `pbpaste` would show me what was in there if I e.g. copied some content from a web page viewed in Safari (which should result in some HTML in the clipboard).

But no matter what I tried, `pbpaste` always just output plain text:

```
$ pbpaste -Prefer html
... plain text ...
```

I had a bit more luck with converting things to RTF first. This works:

```
echo  '<p>語 </p>'| textutil -inputencoding UTF-8 -stdin -format html -convert rtf -stdout | pbcopy -Prtf
```

But even after a lot of experimenting all I was basically pasting was a plain text version of the input and many tags just resulted in the contained text disappearing from what ended up in clipboard.

Another oddity was that it seemed to be erratic about whether it ignored the `-font` argument or not. You can see it picks up the `-font` argument if you do:

```
$ echo 日本語 | textutil -inputencoding UTF-8 -stdin -convert rtf -stdout -font 'Hiragino Sans'
{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset128 HiraginoSans-W0;}
                                                               ^^^^^^^^^^^^^^^
```

But if you say the input is HTML, it ignores the `-font` argument:

```
$ echo <p>日本語</p> | textutil -inputencoding UTF-8 -stdin -format html -convert rtf -stdout -font 'Hiragino Sans'
{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Bold;\f1\froman\fcharset0 Times-Roman;}
                                                                                               ^^^^^^^^^^^
```

In the end, `textutil` added nothing useful to the mix and the best I could do was copying plaintext to the clipboard:

```
$ echo 日本語 | pbcopy
```

Pandoc
------

I _suspect_ you may get much better results if you use something more actively developer/supported than `pbcopy` and `textutil`.

E.g. use [Pandoc](https://github.com/jgm/pandoc) if format conversion is required and interact with the clipboard directly using Python.

Using the clipboard with anything other than plain text (e.g. see [`pyperclip`](https://github.com/asweigart/pyperclip)) doesn't seem to have any great cross-platform solutions.

You can access the clipboard in a platform specific manner using e.g. [`pywin32`](https://github.com/mhammond/) (Python for Win32) or [PyObjC](https://pyobjc.readthedocs.io/en/latest/) (for Mac).

But this is all fairly low level, e.g. to access the clipboard using PyObjC:

```
from AppKit import NSPasteboard, NSStringPboardType

pb = NSPasteboard.generalPasteboard()
pbstring = pb.stringForType_(NSStringPboardType)
```

There are no obvious cover-all solutions for Linux but e.g. if you know you're in a Gnome environment you may be able to use [`Gdk.Clipboard`](https://docs.gtk.org/gdk4/class.Clipboard.html) and the [GTK Python bindings](https://www.gtk.org/docs/language-bindings/python) (who knows it may work even if you're not in a Gnome environment - I suspect if should be smart enough to interact with the system clipboard irrespective of the desktop environment being used).

Morphology
----------

As noted above, ChatGPT isn't great for furigana. There are many online tools for adding furigana to pasted in text and _Pages_ can add furigana - just select the relevant text and go to the menu _Format / Phonetic Guide Text_ and it'll pop up a little dialog with the suggested furigana, you can click away and the suggested text is added. You can then edit the text for a word if you want e.g. click 日本 and the guide text dialog comes up and you can e.g. change にっぽん to にほん. Unfortunately, it adds furigana for all kana - you can click on each one and then click _Remove Phonetic Guide Text_ but this is a bit of a nuisance.

And there are programmatic solutions but nothing with English language documentation seems to be actively developed. The biggest things I could find were:

* [kuroshiro](https://github.com/hexenq/kuroshiro) - JavaScript, 858 stars, last commit 4 years ago.
* [MikimotoH/furigana](https://github.com/MikimotoH/furigana) - Python, 95 stars, last commit 4 years ago.
* [Japanese Toolkit JS](https://github.com/echamudi/japanese-toolkit) - TypeScript, 51 starts, last commit 3 years ago.

Yahoo Japan (Yahoo, while largely dead in the rest of the world, is still really big in Japan) maintains a set of _Text Analytics_ APIs that includes the [FuriganaService](https://developer.yahoo.co.jp/webapi/jlp/furigana/v2/furigana.html) (with Python example [here](https://developer.yahoo.co.jp/webapi/jlp/sample/sample10.html)).

The resulting JSON may look hard to consume but while the _MikimotoH/furigana_ project may be dead, you can see in its [`furigana.py`](https://github.com/MikimotoH/furigana/blob/master/furigana/furigana.py) that it's actually fairly easy to take structured data like the JSON returned by the Yahoo API and produce HTML with `<ruby>` tags (start from the `print_html` in the `furigana.py` file).

_MikimotoH/furigana_ uses the [MeCab Part-of-Speech and Morphological Analyzer](https://taku910.github.io/mecab/) - it seems popular but doesn't seem to have had any active development since 2013.

However, there are actively maintained Python bindings - [`mecab-python3`](https://github.com/SamuraiT/mecab-python3). The current maintainer of those bindings (Paul O'Leary McCann) also maintains what he calls a "Cython wrapper for MeCab with a Pythonic interface" called [`fugashi`](https://github.com/polm/fugashi).

Paul also suggests [`sudachi.rs`](https://github.com/WorksApplications/sudachi.rs) (written in Rust but with its own [python bindings](https://github.com/WorksApplications/sudachi.rs/tree/develop/python)) as an actively maintained alternative to MeCab (which apparently also has less installation issues around the underlying binary).

Japanese Toolkit JS isn't actively developed but its also interesting in that you can see how it uses its own dictionaries (see the [`kanji`](https://github.com/echamudi/japanese-toolkit/tree/master/packages/kanji) subpackage) to determine readings. And then uses these readings in the [`furigana`](https://github.com/echamudi/japanese-toolkit/tree/master/packages/furigana) subpackage.

### School grade level

It's interesting to see in some of the furigana solutions above that you can get them to target a specific reading level, e.g. only generate furigana for kanji that have not been covered by a specific grade in school.

E.g. with the Yahoo API, you can specify the `grade` value that takes these values:

> 1: For first graders. Furigana will be added to all kanji.
> 2: For second graders. Furigana will not be added to kanji learned in the first grade.
> 3: For third graders. Furigana will not be added to kanji learned in the first and second grades.
> ...
